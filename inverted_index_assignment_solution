Information Retrieval Assignment - Inverted Index Solution

Objective:
The goal of this exercise is to implement an inverted index and demonstrate how it can be used to efficiently process search queries. 
This solution is presented in Python and covers building the index, processing queries, and optimizing query handling.

Step 1: Building the Inverted Index

Explanation:
An inverted index is a crucial data structure in Information Retrieval (IR) systems. It maps words (tokens) to the documents 
in which they appear, enabling efficient document retrieval based on keywords.

Python Code:

from collections import defaultdict

# Function to build the inverted index
def build_inverted_index(docs):
    inverted_index = defaultdict(list)
    
    for doc_id, text in docs.items():
        # Tokenize the text (lowercase, remove punctuation)
        tokens = text.lower().replace(",", "").replace(".", "").split()
        # Associate each token with its document ID
        for token in set(tokens):  # Set to avoid duplicates in the same document
            inverted_index[token].append(doc_id)
    
    return dict(inverted_index)

# Example documents
documents = {
    1: "he likes to wink, he likes to drink.",
    2: "he winked and drank.",
    3: "they like to wink and drink together."
}

# Build the inverted index
inverted_index = build_inverted_index(documents)

# Output the inverted index
print(inverted_index)


Step 2: Query Processing using the Inverted Index

Explanation:
Once the inverted index is built, it can be used to process search queries. Queries can be processed using logical operators such as 
AND and OR to retrieve documents that contain the desired terms.

Python Code for AND/OR Queries:

# Function to process queries using AND logic
def process_and_query(query, inverted_index):
    terms = query.lower().split()
    result = set(inverted_index[terms[0]]) if terms[0] in inverted_index else set()
    
    for term in terms[1:]:
        if term in inverted_index:
            result = result.intersection(inverted_index[term])
        else:
            result = set()
            break
    
    return result

# Function to process queries using OR logic
def process_or_query(query, inverted_index):
    terms = query.lower().split()
    result = set()
    
    for term in terms:
        if term in inverted_index:
            result = result.union(inverted_index[term])
    
    return result

# Example AND query
and_query = "wink drink"
and_result = process_and_query(and_query, inverted_index)
print(f"Documents matching '{and_query}' (AND):", and_result)

# Example OR query
or_query = "wink drank"
or_result = process_or_query(or_query, inverted_index)
print(f"Documents matching '{or_query}' (OR):", or_result)


Step 3: Query Optimization

Explanation:
Query optimization ensures that the query processing is efficient. By starting with the term that has the smallest posting list, 
we can reduce the number of comparisons during the merging of the posting lists.

Results:
Inverted Index Output:
{
 'wink': [1, 3],
 'he': [1, 2],
 'drink': [1, 3],
 'to': [1, 3],
 'likes': [1],
 'drank': [2],
 'winked': [2],
 'and': [2, 3],
 'together': [3],
 'they': [3],
 'like': [3]
}

Query Results:
- AND Query ("wink drink"): Documents matching: [1, 3]
- OR Query ("wink drank"): Documents matching: [1, 2, 3]


Conclusion:
This solution provides a full implementation of an inverted index in Python, along with the ability to process queries using AND/OR logic. 
By optimizing the query processing, we ensure efficient retrieval from large document collections.
